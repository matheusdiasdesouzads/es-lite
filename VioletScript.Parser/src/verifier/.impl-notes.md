# Verifier notes

Some of the notes in this document also apply to bytecode import phase.

- [x] Enum definitions "override" the `valueOf()` and `toString()` methods.
- [ ] Prohibit destructuring patterns in variable definitions of type-block, package-block or namespace-block.
- [x] `typeExp.<>`: verify constraints
- [x] `exp.<>`: verify constraints
- [x] `v as T` or `v as? T` DO NOT turn `T` into `T?`; instead, verification for such conversion produces a `ConversionValue` with `isOptional` set to `true`, and `TypeConversions.convertExploicit(...)` will properly wrap `T` into `T?` if needed.
- [ ] Prohibit non-read-only non-static variable definitions for `[Value]` classes.
- [x] Instance methods can be overriden with additional optional parameters and a contravariant return type or any return type if the original return type is any.
- [ ] Decorators must not be allowed in certain places, like over ordinary functions and ordinary variables.
- [ ] Prohibit non-static fragmented variable definitions in enum frame. Or do this only at the bytecode level?

## To Be Implemented

### `x is y:C`

- [x] Use `exp.GetTypeTestFrames` to gather binary `is` frames.
- [x] Attach a new frame to this binary operator and define `y` there. Binary `&&` operator recursively pushes frames from left operand when verifying right operand and pops them back. Ternary operator recursively pushes frames from its test when verifying the consequent expression and pops them back.
- [x] Few statements should push any frames recursively from condition expressions when verifying their bodies and pop back. This is done only for `if (test)`, `while (test)` and `for (; test;)`.