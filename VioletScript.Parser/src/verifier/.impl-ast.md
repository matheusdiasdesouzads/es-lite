# AST tasks

- [x] Type expressions
  - [x] Identifier
  - [x] Any
  - [x] Void
  - [x] Undefined
  - [x] Null
  - [x] Function
  - [x] Array
  - [x] Tuple
  - [x] Record
  - [x] Parentheses
  - [x] Union
  - [x] Member
  - [x] Generic instantiation
  - [x] Nullable
  - [x] Non-nullable
  - [x] Typed type expression
- [x] Variable binding
- [x] Simple variable declaration
- [x] Destructuring patterns
  - [x] `VerifyDestructuringPattern(pattern, readOnly, output, visibility, inferredType);`
    - This is used for binding patterns.
  - [x] `VerifyAssignmentDestructuringPattern(pattern, type);`
    - This is used by assignment expressions.
  - [x] Bind
  - [x] Array
  - [x] Record
- [x] Constant Expressions
  - [x] `VerifyConstantExp(exp, faillible, expectedType?)`
  - [x] `LimitConstantExpType(exp, toType, faillible?)`
    - [x] `LimitStrictConstantExpType`
      - Limits constant expression's type without implicit conversion.
  - [x] Identifier
  - [x] Unary
  - [x] Binary
  - [x] Default
  - [x] Object initializer
  - [x] Array initializer
  - [x] Member
  - [x] String literal
  - [x] Null literal
  - [x] Boolean literal
  - [x] Numeric literal
  - [x] Conditional
  - [x] Parentheses
  - [x] List
- [x] Expressions
  - [x] `VerifyExp(exp, expectedType?, instantiatingGeneric?, writting?)`
  - [x] `VerifyExpAsValue(exp, expectedType?, instantiatingGeneric?, writting?)`
    - Verifies expression and fails if it is not a value.
  - [x] `LimitExpType(exp, toType)`
    - [x] `LimitStrictExpType(exp, toType)`
      - Limits expression's type without implicit conversion.
  - [x] Identifier
  - [x] Member
  - [x] `import.meta`
  - [x] Embed
  - [x] Unary
    - [x] Await
    - [x] Yield
    - [x] Delete
    - [x] Typeof
    - [x] Void
    - [x] Logical not
    - [x] Positive
    - [x] Negate
    - [x] Bitwise not
    - [x] Non-null
    - [x] Pre-increment
    - [x] Pre-decrement
    - [x] Post-increment
    - [x] Post-decrement
  - [x] Binary
    - [x] In
    - [x] Equals, not equals
    - [x] Strict equals, strict not equals
    - [x] Logical and, logical xor, logical or
    - [x] Null coalescing
    - [x] Add, subtract, multiply, divide, remainder, power, bitwise and, bitwise xor, bitwise or, left shift, right shift, unsigned right shift, less than, greater than, less than or equals, greater than or equals
  - [x] Type binary (`as is instanceof`)
    - [x] `bindsTo`
  - [x] Default
  - [x] Function
  - [x] Object initializer
  - [x] Array initializer
  - [x] Markup initializer
  - [x] Markup list initializer
  - [x] Index
    - [x] Possibly `?.[k]`
  - [x] Call
    - [x] Possibly `?.()`
  - [x] This literal
  - [x] String literal
  - [x] Null literal
  - [x] Boolean literal
  - [x] Numeric literal
  - [x] `RegExp` literal
  - [x] Conditional
  - [x] Parentheses
  - [x] List
  - [x] Generic instantiation
  - [x] Assignment
    - [x] When verifying left-hand side, pass `writting = true`.
  - [x] New
  - [x] Super
- [x] Program
- [x] Package definitions
- [x] Generics
- [ ] Statements
  - [ ] Declarations
    - [x] Import directive (phased)
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.ImportOrAliasPhase1`
      - [x] `VerifyPhase.ImportOrAliasPhase2`
    - [x] Use namespace directive (phased)
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.ImportOrAliasPhase1`
      - [x] `VerifyPhase.ImportOrAliasPhase2`
    - [x] Namespaces
      - [x] `VerifyPhase.Phase1`
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.Phase3`
      - [x] `VerifyPhase.Phase4`
      - [x] `VerifyPhase.Phase5`
      - [x] `VerifyPhase.Phase6`
      - [x] `VerifyPhase.Phase7`
    - [x] Namespace alias
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.ImportOrAliasPhase1`
      - [x] `VerifyPhase.ImportOrAliasPhase2`
    - [x] Variables
      - [x] `VerifyPhase.Phase1`
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.Phase3`
      - [x] `VerifyPhase.Phase7`
    - [ ] Set `activation.m_ActivationThisOrClassStaticThis` as either a normal `ThisValue` or `ClassStaticThis` value for class, enum or interface methods.
      - [x] Ordinary functions
      - [x] Constructor
      - [ ] Proxy
      - [ ] Getter
      - [ ] Setter
    - [ ] Functions
      - [x] Ordinary (`Ast.FunctionDefinition`)
        - [x] `VerifyPhase.Phase1`
        - [x] `VerifyPhase.Phase2`
        - [x] `VerifyPhase.Phase3`
        - [x] `VerifyPhase.Phase7`
      - [x] Constructor (`Ast.ConstructorDefinition`)
        - [x] `VerifyPhase.Phase1`
        - [x] `VerifyPhase.Phase2`
        - [x] `VerifyPhase.Phase3`
        - [x] `VerifyPhase.Phase7`
      - [x] Proxy (`Ast.ProxyDefinition`)
        - [x] `VerifyPhase.Phase1`
        - [x] `VerifyPhase.Phase2`
        - [x] `VerifyPhase.Phase3`
        - [ ] `VerifyPhase.Phase7`
          - [ ] Resolve parameter bindings and body
      - [ ] Getter (`Ast.GetterDefinition`)
        - [ ] `VerifyPhase.Phase1`
          - [ ] Create or complement virtual property
          - [ ] Assign `virtualProperty.ParentDefinition` to `m_Frame.TypeFromFrame ?? m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
          - [ ] Assign `method.ParentDefinition` to `m_Frame.TypeFromFrame ?? m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
        - [ ] `VerifyPhase.Phase2`
          - [ ] Resolve signature without resolving the parameter bindings, like on ordinary functions. Validate the signature also.
        - [ ] `VerifyPhase.Phase3`
          - [ ] If it is a class instance method, do not allow shadowing property or override method if marked 'override'.
        - [ ] `VerifyPhase.Phase7`
          - [ ] Resolve bindings and body like on ordinary functions
      - [ ] Setter (`Ast.SetterDefinition`)
        - [ ] `VerifyPhase.Phase1`
          - [ ] Create or complement virtual property
          - [ ] Assign `virtualProperty.ParentDefinition` to `m_Frame.TypeFromFrame ?? m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
          - [ ] Assign `method.ParentDefinition` to `m_Frame.TypeFromFrame ?? m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
        - [ ] `VerifyPhase.Phase2`
          - [ ] Resolve signature without resolving the parameter bindings, like on ordinary functions. It will also infer the type for the first parameter and the return type if any getter was defined before. Validate the signature also.
        - [ ] `VerifyPhase.Phase3`
          - [ ] If it is a class instance method, do not allow shadowing property or override method if marked 'override'.
        - [ ] `VerifyPhase.Phase7`
          - [ ] Resolve bindings and body like on ordinary functions, however the first parameter, _if any_ (in case the _FunctionCommon_ is valid), has its type inferred from the signature resolved from phase 2.
    - [x] Classes
      - [x] `VerifyPhase.Phase1`
        - [x] Create type with proper flags (final?, value?, dontInit?)
        - [x] Assign `type.ParentDefinition` to `m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
        - [x] Create class frame and attach it to the definition
        - [x] If any generics, call `FragmentedA_VerifyTypeParameters` for them before visiting block and after initializing the class frame (pass the class type as the third argument)
        - [x] Visit block with phase 1
      - [x] `VerifyPhase.Phase2`
        - [x] Resolve `extends` and `implements` clauses.
          - [x] Do not allow to extend a final class.
          - [x] Do not allow to extend the class itself (that is, the `extends` clause must not resolve  a subtype and must not be equals the class itself).
          - [x] Each `implements` item must be an interface.
          - [x] It is a verify error if the class is already a subtype of a given `implements` interface.
        - [x] Call `AddLimitedKnownSubtype` after resolving super type
        - [x] Call `FragmentedB_VerifyTypeParameters` for generics if any
      - [x] `VerifyPhase.Phase3`
      - [x] `VerifyPhase.Phase4`
      - [x] `VerifyPhase.Phase5`
        - [x] Call `InterfaceImpl.VerifyImpl` to verify each implemented interface
      - [x] `VerifyPhase.Phase6`
      - [x] `VerifyPhase.Phase7`
        - [x] Resolve decorators
    - [x] Interfaces
      - [x] `VerifyPhase.Phase1`
        - [x] Assign `type.ParentDefinition` to `m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
        - [x] Create interface frame and attach it to the definition
        - [x] If any generics, call `FragmentedA_VerifyTypeParameters` for them before visiting block and after initializing the interface frame
        - [x] Visit block with phase 1
      - [x] `VerifyPhase.Phase2`
        - [x] Resolve `extends` clause if any.
          - [x] Do not allow to extend the interface itself (that is, each item of the `extends` clause must be a non-subtype interface and not equals the interface itself).
        - [x] Call `AddLimitedKnownSubtype` after resolving each super type
        - [x] Call `FragmentedB_VerifyTypeParameters` for generics if any
      - [x] `VerifyPhase.Phase3`
      - [x] `VerifyPhase.Phase4`
      - [x] `VerifyPhase.Phase5`
      - [x] `VerifyPhase.Phase6`
      - [x] `VerifyPhase.Phase7`
        - [x] Resolve decorators
    - [x] Enums
      - [x] `VerifyPhase.Phase1`
        - [x] Assign `type.ParentDefinition` to `m_Frame.NamespaceFromFrame ?? m_Frame.PackageFromFrame`
        - [x] Create enum frame and attach it to the definition
        - [x] Resolve the `wraps` clause if any.
        - [x] Call `enumType.EnumInitializeMethods` after resolving `wraps`
        - [x] Visit block with phase 1, but don't use `fragmented_verifyStatementSeq`; call it for all directives except for variable definitions without `static` modifier.
        - [x] Fully resolve variable definitions without `static` modifier, resulting in new enum variants.
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.Phase3`
      - [x] `VerifyPhase.Phase4`
      - [x] `VerifyPhase.Phase5`
      - [x] `VerifyPhase.Phase6`
      - [x] `VerifyPhase.Phase7`
        - [x] Resolve decorators
    - [x] Types
      - [x] `VerifyPhase.Phase2`
      - [x] `VerifyPhase.Phase3`
      - [x] `VerifyPhase.ImportOrAliasPhase1`
      - [x] `VerifyPhase.ImportOrAliasPhase2`
  - [x] Expression statement
  - [x] Empty statement
  - [x] Block
  - [x] Super statement
  - [x] Import
  - [x] If
  - [x] Do
  - [x] While
  - [x] Break
  - [x] Continue
  - [x] Return
  - [x] Throw
  - [x] Try
  - [x] Labeled statement
  - [x] For
  - [x] `for..in`
  - [x] `for each`
  - [x] Switch
  - [x] `switch type`
  - [x] Include
  - [x] `use namespace`
  - [x] `use resource`
  - [x] With
